import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import '../constants/app_constants.dart';
import '../models/activity_script.dart';
import '../models/power.dart';
import '../providers/avatar_provider.dart';
import '../providers/activity_authoring_provider.dart';
import '../providers/activities_provider.dart';
import '../widgets/gradient_button.dart';

/// Activity Authoring Screen - Goldfire Phase 1 Integration
/// Allows users to author activities with Activity Types and Power associations
class ActivityAuthoringScreen extends ConsumerStatefulWidget {
  const ActivityAuthoringScreen({super.key});

  @override
  ConsumerState<ActivityAuthoringScreen> createState() => _ActivityAuthoringScreenState();
}

class _ActivityAuthoringScreenState extends ConsumerState<ActivityAuthoringScreen> {
  final _formKey = GlobalKey<FormState>();
  final _titleController = TextEditingController();
  final _descriptionController = TextEditingController();
  final _instructionsController = TextEditingController();
  final _tagsController = TextEditingController();

  ActivityType? _selectedActivityType;
  PowerType? _selectedPrimaryPower;
  final List<PowerType> _selectedSecondaryPowers = [];
  ActivityDifficulty _selectedDifficulty = ActivityDifficulty.beginner;
  int _estimatedDuration = 15;
  int _experienceReward = 25;
  bool _requiresVerification = false;
  bool _isGroupActivity = false;
  int _minParticipants = 1;
  int _maxParticipants = 1;
  bool _isSubmitting = false;

  @override
  void dispose() {
    _titleController.dispose();
    _descriptionController.dispose();
    _instructionsController.dispose();
    _tagsController.dispose();
    super.dispose();
  }

  void _addSecondaryPower(PowerType power) {
    if (_selectedSecondaryPowers.length < 4 && !_selectedSecondaryPowers.contains(power)) {
      setState(() {
        _selectedSecondaryPowers.add(power);
      });
    }
  }

  void _removeSecondaryPower(PowerType power) {
    setState(() {
      _selectedSecondaryPowers.remove(power);
    });
  }

  Future<void> _submitActivity() async {
    if (!_formKey.currentState!.validate()) return;
    if (_selectedActivityType == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select an Activity Type')),
      );
      return;
    }
    if (_selectedPrimaryPower == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please select a Primary Power')),
      );
      return;
    }

    setState(() => _isSubmitting = true);

    try {
      final avatar = ref.read(selectedAvatarProvider);
      if (avatar == null) {
        throw Exception('Avatar not found');
      }

      // Create activity script
      final activity = ActivityScript(
        id: '', // Will be generated by blockchain
        title: _titleController.text.trim(),
        description: _descriptionController.text.trim(),
        instructions: _instructionsController.text.trim(),
        activityType: _selectedActivityType!,
        primaryPower: _selectedPrimaryPower!,
        secondaryPowers: _selectedSecondaryPowers,
        difficulty: _selectedDifficulty,
        estimatedDuration: _estimatedDuration,
        experienceReward: _experienceReward,
        authorId: avatar?.id ?? '',
        authorName: avatar?.name ?? '',
        status: ActivityStatus.draft,
        createdAt: DateTime.now(),
        tags: _tagsController.text
            .split(',')
            .map((tag) => tag.trim())
            .where((tag) => tag.isNotEmpty)
            .toList(),
        isGroupActivity: _isGroupActivity,
        minParticipants: _minParticipants,
        maxParticipants: _maxParticipants,
        metadata: {
          'requiresVerification': _requiresVerification,
        },
      );

      // Save to blockchain via activity authoring provider
      final authoringNotifier = ref.read(activityAuthoringProvider.notifier);
      final txHash = await authoringNotifier.createActivity(
        activity: activity,
        decentralizedStorageRef: null, // TODO: Upload to IPFS and get hash
      );

      if (mounted) {
        // Refresh activities list to show the new activity
        ref.read(activitiesProvider.notifier).refresh();
        
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Activity created successfully! Transaction: ${txHash.substring(0, 10)}...'),
            backgroundColor: AppConstants.successColor,
          ),
        );
        Navigator.of(context).pop();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error creating activity: $e'),
            backgroundColor: AppConstants.errorColor,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isSubmitting = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Author Activity'),
        elevation: 0,
      ),
      body: Form(
        key: _formKey,
        child: ListView(
          padding: const EdgeInsets.all(AppConstants.spacingM),
          children: [
            // Activity Type Selection
            _buildSectionTitle('Activity Type (Required)'),
            const SizedBox(height: AppConstants.spacingS),
            _buildActivityTypeSelector(),
            const SizedBox(height: AppConstants.spacingL),

            // Basic Information
            _buildSectionTitle('Basic Information'),
            const SizedBox(height: AppConstants.spacingS),
            TextFormField(
              controller: _titleController,
              decoration: const InputDecoration(
                labelText: 'Activity Title',
                hintText: 'Enter a descriptive title',
                border: OutlineInputBorder(),
              ),
              validator: (value) {
                if (value == null || value.trim().isEmpty) {
                  return 'Title is required';
                }
                if (value.trim().length < AppConstants.minActivityTitleLength) {
                  return 'Title must be at least ${AppConstants.minActivityTitleLength} characters';
                }
                if (value.trim().length > AppConstants.maxActivityTitleLength) {
                  return 'Title must be less than ${AppConstants.maxActivityTitleLength} characters';
                }
                return null;
              },
            ),
            const SizedBox(height: AppConstants.spacingM),
            TextFormField(
              controller: _descriptionController,
              decoration: const InputDecoration(
                labelText: 'Description',
                hintText: 'Describe what participants will do',
                border: OutlineInputBorder(),
              ),
              maxLines: 3,
              validator: (value) {
                if (value == null || value.trim().isEmpty) {
                  return 'Description is required';
                }
                if (value.trim().length < AppConstants.minActivityDescriptionLength) {
                  return 'Description must be at least ${AppConstants.minActivityDescriptionLength} characters';
                }
                return null;
              },
            ),
            const SizedBox(height: AppConstants.spacingM),
            TextFormField(
              controller: _instructionsController,
              decoration: const InputDecoration(
                labelText: 'Instructions',
                hintText: 'Step-by-step instructions for participants',
                border: OutlineInputBorder(),
              ),
              maxLines: 5,
              validator: (value) {
                if (value == null || value.trim().isEmpty) {
                  return 'Instructions are required';
                }
                return null;
              },
            ),
            const SizedBox(height: AppConstants.spacingL),

            // Power Associations
            _buildSectionTitle('Power Associations'),
            const SizedBox(height: AppConstants.spacingS),
            _buildPowerSelector(),
            const SizedBox(height: AppConstants.spacingL),

            // Activity Settings
            _buildSectionTitle('Activity Settings'),
            const SizedBox(height: AppConstants.spacingS),
            _buildActivitySettings(),
            const SizedBox(height: AppConstants.spacingL),

            // Tags
            _buildSectionTitle('Tags (Optional)'),
            const SizedBox(height: AppConstants.spacingS),
            TextFormField(
              controller: _tagsController,
              decoration: const InputDecoration(
                labelText: 'Tags',
                hintText: 'Comma-separated tags (e.g., networking, team-building)',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: AppConstants.spacingXL),

            // Submit Button
            GradientButton(
              onPressed: _isSubmitting ? null : _submitActivity,
              child: _isSubmitting
                  ? const SizedBox(
                      height: 20,
                      width: 20,
                      child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white),
                    )
                  : const Text('Create Activity'),
            ),
            const SizedBox(height: AppConstants.spacingL),
          ],
        ),
      ),
    );
  }

  Widget _buildSectionTitle(String title) {
    return Text(
      title,
      style: GoogleFonts.inter(
        fontSize: AppConstants.fontSizeLarge,
        fontWeight: FontWeight.w600,
        color: AppConstants.textPrimaryColor,
      ),
    );
  }

  Widget _buildActivityTypeSelector() {
    return Wrap(
      spacing: AppConstants.spacingS,
      runSpacing: AppConstants.spacingS,
      children: ActivityType.values.map((type) {
        final typeString = type.toString().split('.').last;
        final isSelected = _selectedActivityType == type;
        final color = AppConstants.activityTypeColors[typeString] ?? AppConstants.primaryColor;
        final icon = AppConstants.activityTypeIcons[typeString] ?? 'ðŸ“';

        return GestureDetector(
          onTap: () => setState(() => _selectedActivityType = type),
          child: Container(
            padding: const EdgeInsets.symmetric(
              horizontal: AppConstants.spacingM,
              vertical: AppConstants.spacingS,
            ),
            decoration: BoxDecoration(
              color: isSelected ? color : Colors.transparent,
              border: Border.all(
                color: isSelected ? color : AppConstants.textSecondaryColor,
                width: 2,
              ),
              borderRadius: BorderRadius.circular(AppConstants.borderRadiusM),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(icon, style: const TextStyle(fontSize: 20)),
                const SizedBox(width: AppConstants.spacingS),
                Text(
                  _getActivityTypeLabel(type),
                  style: TextStyle(
                    color: isSelected ? Colors.white : AppConstants.textPrimaryColor,
                    fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                  ),
                ),
              ],
            ),
          ),
        );
      }).toList(),
    );
  }

  Widget _buildPowerSelector() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text('Primary Power (Required)', style: TextStyle(fontWeight: FontWeight.w500)),
        const SizedBox(height: AppConstants.spacingS),
        Wrap(
          spacing: AppConstants.spacingS,
          runSpacing: AppConstants.spacingS,
          children: PowerType.values.map((power) {
            final powerString = power.toString().split('.').last;
            final isSelected = _selectedPrimaryPower == power;
            final color = AppConstants.powerColors[powerString] ?? AppConstants.primaryColor;

            return GestureDetector(
              onTap: () => setState(() => _selectedPrimaryPower = power),
              child: Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: AppConstants.spacingM,
                  vertical: AppConstants.spacingS,
                ),
                decoration: BoxDecoration(
                  color: isSelected ? color : Colors.transparent,
                  border: Border.all(
                    color: isSelected ? color : AppConstants.textSecondaryColor,
                    width: 2,
                  ),
                  borderRadius: BorderRadius.circular(AppConstants.borderRadiusM),
                ),
                child: Text(
                  _getPowerLabel(power),
                  style: TextStyle(
                    color: isSelected ? Colors.white : AppConstants.textPrimaryColor,
                    fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                  ),
                ),
              ),
            );
          }).toList(),
        ),
        if (_selectedPrimaryPower != null) ...[
          const SizedBox(height: AppConstants.spacingM),
          const Text('Secondary Powers (Optional, up to 4)', style: TextStyle(fontWeight: FontWeight.w500)),
          const SizedBox(height: AppConstants.spacingS),
          Wrap(
            spacing: AppConstants.spacingS,
            runSpacing: AppConstants.spacingS,
            children: PowerType.values.where((p) => p != _selectedPrimaryPower).map((power) {
              final powerString = power.toString().split('.').last;
              final isSelected = _selectedSecondaryPowers.contains(power);
              final color = AppConstants.powerColors[powerString] ?? AppConstants.primaryColor;
              final canAdd = _selectedSecondaryPowers.length < 4;

              return GestureDetector(
                onTap: canAdd || isSelected
                    ? () {
                        if (isSelected) {
                          _removeSecondaryPower(power);
                        } else {
                          _addSecondaryPower(power);
                        }
                      }
                    : null,
                child: Opacity(
                  opacity: canAdd || isSelected ? 1.0 : 0.5,
                  child: Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: AppConstants.spacingM,
                      vertical: AppConstants.spacingS,
                    ),
                    decoration: BoxDecoration(
                      color: isSelected ? color : Colors.transparent,
                      border: Border.all(
                        color: isSelected ? color : AppConstants.textSecondaryColor,
                        width: 2,
                      ),
                      borderRadius: BorderRadius.circular(AppConstants.borderRadiusM),
                    ),
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        if (isSelected)
                          const Icon(Icons.check, size: 16, color: Colors.white)
                        else
                          const Icon(Icons.add, size: 16, color: AppConstants.textSecondaryColor),
                        const SizedBox(width: AppConstants.spacingXS),
                        Text(
                          _getPowerLabel(power),
                          style: TextStyle(
                            color: isSelected ? Colors.white : AppConstants.textPrimaryColor,
                            fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              );
            }).toList(),
          ),
        ],
      ],
    );
  }

  Widget _buildActivitySettings() {
    return Column(
      children: [
        // Difficulty
        DropdownButtonFormField<ActivityDifficulty>(
          value: _selectedDifficulty,
          decoration: const InputDecoration(
            labelText: 'Difficulty',
            border: OutlineInputBorder(),
          ),
          items: ActivityDifficulty.values.map((difficulty) {
            return DropdownMenuItem(
              value: difficulty,
              child: Text(_getDifficultyLabel(difficulty)),
            );
          }).toList(),
          onChanged: (value) => setState(() => _selectedDifficulty = value!),
        ),
        const SizedBox(height: AppConstants.spacingM),

        // Duration
        Row(
          children: [
            Expanded(
              child: Text('Estimated Duration: $_estimatedDuration minutes'),
            ),
            Expanded(
              child: Slider(
                value: _estimatedDuration.toDouble(),
                min: 5,
                max: 120,
                divisions: 23,
                label: '$_estimatedDuration min',
                onChanged: (value) => setState(() => _estimatedDuration = value.toInt()),
              ),
            ),
          ],
        ),
        const SizedBox(height: AppConstants.spacingM),

        // Experience Reward
        Row(
          children: [
            Expanded(
              child: Text('Experience Reward: $_experienceReward XP'),
            ),
            Expanded(
              child: Slider(
                value: _experienceReward.toDouble(),
                min: 10,
                max: 200,
                divisions: 19,
                label: '$_experienceReward XP',
                onChanged: (value) => setState(() => _experienceReward = value.toInt()),
              ),
            ),
          ],
        ),
        const SizedBox(height: AppConstants.spacingM),

        // Verification Required
        SwitchListTile(
          title: const Text('Requires Verification'),
          subtitle: const Text('Activity completion must be verified by an authorized verifier'),
          value: _requiresVerification,
          onChanged: (value) => setState(() => _requiresVerification = value),
        ),

        // Group Activity
        SwitchListTile(
          title: const Text('Group Activity'),
          subtitle: const Text('Activity can be completed by multiple participants'),
          value: _isGroupActivity,
          onChanged: (value) => setState(() => _isGroupActivity = value),
        ),

        if (_isGroupActivity) ...[
          const SizedBox(height: AppConstants.spacingM),
          Row(
            children: [
              Expanded(
                child: TextFormField(
                  initialValue: _minParticipants.toString(),
                  decoration: const InputDecoration(
                    labelText: 'Min Participants',
                    border: OutlineInputBorder(),
                  ),
                  keyboardType: TextInputType.number,
                  onChanged: (value) {
                    final intValue = int.tryParse(value);
                    if (intValue != null && intValue > 0) {
                      setState(() => _minParticipants = intValue);
                    }
                  },
                ),
              ),
              const SizedBox(width: AppConstants.spacingM),
              Expanded(
                child: TextFormField(
                  initialValue: _maxParticipants.toString(),
                  decoration: const InputDecoration(
                    labelText: 'Max Participants',
                    border: OutlineInputBorder(),
                  ),
                  keyboardType: TextInputType.number,
                  onChanged: (value) {
                    final intValue = int.tryParse(value);
                    if (intValue != null && intValue >= _minParticipants) {
                      setState(() => _maxParticipants = intValue);
                    }
                  },
                ),
              ),
            ],
          ),
        ],
      ],
    );
  }

  String _getActivityTypeLabel(ActivityType type) {
    switch (type) {
      case ActivityType.personalResources:
        return 'Personal Resources';
      case ActivityType.introductions:
        return 'Introductions';
      case ActivityType.dynamics:
        return 'Dynamics';
      case ActivityType.locales:
        return 'Locales';
      case ActivityType.mythicLens:
        return 'Mythic Lens';
      case ActivityType.alchemy:
        return 'Alchemy';
      case ActivityType.tales:
        return 'Tales';
    }
  }

  String _getPowerLabel(PowerType power) {
    switch (power) {
      case PowerType.courage:
        return 'Courage';
      case PowerType.creativity:
        return 'Creativity';
      case PowerType.connection:
        return 'Connection';
      case PowerType.insight:
        return 'Insight';
      case PowerType.kindness:
        return 'Kindness';
    }
  }

  String _getDifficultyLabel(ActivityDifficulty difficulty) {
    switch (difficulty) {
      case ActivityDifficulty.beginner:
        return 'Beginner';
      case ActivityDifficulty.intermediate:
        return 'Intermediate';
      case ActivityDifficulty.advanced:
        return 'Advanced';
      case ActivityDifficulty.expert:
        return 'Expert';
    }
  }
}

